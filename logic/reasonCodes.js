export const REASON_CODE = Object.freeze({
  UNKNOWN: 'UNKNOWN',
  ENTRY_ALLOWED: 'ENTRY_ALLOWED',
  EXECUTION_INVALID: 'EXECUTION_INVALID',
  A_INVALID: 'A_INVALID',
  NO_ARENA: 'NO_ARENA',
  NO_DEPTH_DATA: 'NO_DEPTH_DATA',
  EXCEPTIONAL_VOLATILITY: 'EXCEPTIONAL_VOLATILITY',
  NO_VALID_SR: 'NO_VALID_SR',
  INSUFFICIENT_STRENGTH: 'INSUFFICIENT_STRENGTH',
  TOO_FAR_FROM_SR: 'TOO_FAR_FROM_SR',
  TOO_CLOSE_TO_SR: 'TOO_CLOSE_TO_SR',
  INSUFFICIENT_TP_DISTANCE: 'INSUFFICIENT_TP_DISTANCE',
  THIN_ORDER_BOOK: 'THIN_ORDER_BOOK',
  NET_EXPECTATION_TOO_LOW: 'NET_EXPECTATION_TOO_LOW',
  MISALIGNED_TREND: 'MISALIGNED_TREND',
  STATE_HOLD: 'STATE_HOLD',
  IMBALANCE_AGAINST_DIRECTION: 'IMBALANCE_AGAINST_DIRECTION',
  LIQUIDITY_DRAIN: 'LIQUIDITY_DRAIN',
  WIDE_SPREAD: 'WIDE_SPREAD',
  DEPTH_DETERIORATED: 'DEPTH_DETERIORATED'
});

const FIXED_REASON_CODES = Object.freeze(Object.values(REASON_CODE));
const FIXED_REASON_SET = new Set(FIXED_REASON_CODES);

const REASON_ALIASES = Object.freeze({
  'EXECUTION_INVALID': REASON_CODE.EXECUTION_INVALID,
  'NO_NEAR_SR': REASON_CODE.INSUFFICIENT_TP_DISTANCE,
  'NO_LOCAL_CHANNEL': REASON_CODE.NO_ARENA,
  'EDGE_NEGATIVE': REASON_CODE.TOO_FAR_FROM_SR,
  'B: NO NEARBY SR CLUSTER': REASON_CODE.NO_VALID_SR,
  'NO_DEPTH_SR': REASON_CODE.NO_DEPTH_DATA,
  'NO_STRUCTURE': REASON_CODE.NO_VALID_SR,
  'HOLDING_POSITION': REASON_CODE.STATE_HOLD,
  'B: NO DEPTH SR': REASON_CODE.NO_DEPTH_DATA,
  'B: THIN ORDER BOOK': REASON_CODE.THIN_ORDER_BOOK,
  'B: NO TP AVAILABLE': REASON_CODE.INSUFFICIENT_TP_DISTANCE,
  'B: TP DISTANCE TOO SHORT': REASON_CODE.INSUFFICIENT_TP_DISTANCE,
  'B: NO STRUCTURAL TP': REASON_CODE.INSUFFICIENT_TP_DISTANCE,
  'B: NO STRUCTURAL PATH': REASON_CODE.NO_VALID_SR,
  'B: INVALID STRUCTURE SNAPSHOT': REASON_CODE.NO_VALID_SR,
  'B: INVALID STRUCTURE SPAN': REASON_CODE.NO_VALID_SR,
  'B: MID POSITION': REASON_CODE.TOO_FAR_FROM_SR,
  'B: WEAK STRUCTURAL MAP': REASON_CODE.INSUFFICIENT_STRENGTH,
  'B: WEAK SR REFERENCE CLUSTER': REASON_CODE.INSUFFICIENT_STRENGTH,
  'B: LOW EXECUTION QUALITY': REASON_CODE.INSUFFICIENT_STRENGTH,
  'B: OUTSIDE A ARENA': REASON_CODE.NO_ARENA,
  'B: BAR1H SPAN FLOOR UNMET': REASON_CODE.NO_ARENA,
  'B: REGIME MISALIGNMENT': REASON_CODE.MISALIGNED_TREND,
  'B: HIGHER_TF_CONFLICT': REASON_CODE.MISALIGNED_TREND,
  'B: FLOW HOSTILE FOR LONG': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: FLOW HOSTILE FOR SHORT': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: FLOW DIVERGENCE (5S VS 60S)': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: FUNDING HOSTILE FOR LONG': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: FUNDING HOSTILE FOR SHORT': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: PREMIUM HOSTILE FOR LONG': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: PREMIUM HOSTILE FOR SHORT': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: OI-PRICE TRAP FOR LONG': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: OI-PRICE TRAP FOR SHORT': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: OI-PRICE TRAP GATE BLOCKED': REASON_CODE.IMBALANCE_AGAINST_DIRECTION,
  'B: IMPACT SPREAD TOO WIDE': REASON_CODE.WIDE_SPREAD,
  'B: NET_EDGE_BELOW_MIN': REASON_CODE.NET_EXPECTATION_TOO_LOW,
  'B: LIVE NO-ORDER UNTIL A STABLE': REASON_CODE.STATE_HOLD,
  'B: STARTUP NO-ORDER WINDOW': REASON_CODE.STATE_HOLD,
  'B: NO MID PRICE': REASON_CODE.A_INVALID,
  'B: NO EQUITY': REASON_CODE.A_INVALID,
  'B: INVALID TPDISTANCE': REASON_CODE.INSUFFICIENT_TP_DISTANCE,
  'B: INVALID TP DISTANCE': REASON_CODE.INSUFFICIENT_TP_DISTANCE,
  'B: INVALID LOT RATIO CONFIG': REASON_CODE.A_INVALID,
  'A: DATA NOT READY': REASON_CODE.A_INVALID,
  'A: BAR1H NOT READY': REASON_CODE.A_INVALID,
  'A: NO VALID C': REASON_CODE.A_INVALID,
  'A: NO VALID PRICE': REASON_CODE.A_INVALID
});

function tokenizeUpper(raw) {
  return String(raw ?? '')
    .toUpperCase()
    .replace(/[^A-Z0-9_]+/g, ' ')
    .split(/\s+/)
    .filter(Boolean);
}

export function resolveReasonCode(rawReason, fallback = REASON_CODE.UNKNOWN) {
  const normalized = String(rawReason ?? '').toUpperCase().trim();
  if (!normalized) return fallback;

  if (FIXED_REASON_SET.has(normalized)) return normalized;
  if (REASON_ALIASES[normalized]) return REASON_ALIASES[normalized];

  // 厳格寄り: 部分一致ではなくトークン一致でコード抽出
  const tokens = tokenizeUpper(normalized);
  for (const token of tokens) {
    if (FIXED_REASON_SET.has(token) && token !== REASON_CODE.UNKNOWN) {
      return token;
    }
  }

  if (normalized.includes('ENTRY ALLOWED')) return REASON_CODE.ENTRY_ALLOWED;
  return fallback;
}
